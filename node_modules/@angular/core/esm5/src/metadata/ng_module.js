/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { __read, __spread } from "tslib";
import { ɵɵdefineInjector } from '../di/interface/defs';
import { convertInjectableProviderToFactory } from '../di/util';
import { compileNgModule as render3CompileNgModule } from '../render3/jit/module';
import { makeDecorator } from '../util/decorators';
var ɵ0 = function (ngModule) { return ngModule; }, ɵ1 = 
/**
 * Decorator that marks the following class as an NgModule, and supplies
 * configuration metadata for it.
 *
 * * The `declarations` and `entryComponents` options configure the compiler
 * with information about what belongs to the NgModule.
 * * The `providers` options configures the NgModule's injector to provide
 * dependencies the NgModule members.
 * * The `imports` and `exports` options bring in members from other modules, and make
 * this module's members available to others.
 */
function (type, meta) { return SWITCH_COMPILE_NGMODULE(type, meta); };
/**
 * @Annotation
 * @publicApi
 */
export var NgModule = makeDecorator('NgModule', ɵ0, undefined, undefined, ɵ1);
function preR3NgModuleCompile(moduleType, metadata) {
    var imports = (metadata && metadata.imports) || [];
    if (metadata && metadata.exports) {
        imports = __spread(imports, [metadata.exports]);
    }
    moduleType.ɵinj = ɵɵdefineInjector({
        factory: convertInjectableProviderToFactory(moduleType, { useClass: moduleType }),
        providers: metadata && metadata.providers,
        imports: imports,
    });
}
export var SWITCH_COMPILE_NGMODULE__POST_R3__ = render3CompileNgModule;
var SWITCH_COMPILE_NGMODULE__PRE_R3__ = preR3NgModuleCompile;
var SWITCH_COMPILE_NGMODULE = SWITCH_COMPILE_NGMODULE__POST_R3__;
export { ɵ0, ɵ1 };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWMvRG93bmxvYWRzLzA4LWZvcm11bGFyaW9zL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2VzbTUvc3JjL21ldGFkYXRhL25nX21vZHVsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkEyQzhCLGtDQUFpQyIsImZpbGUiOiJuZ19tb2R1bGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBfX3JlYWQsIF9fc3ByZWFkIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyDJtcm1ZGVmaW5lSW5qZWN0b3IgfSBmcm9tICcuLi9kaS9pbnRlcmZhY2UvZGVmcyc7XG5pbXBvcnQgeyBjb252ZXJ0SW5qZWN0YWJsZVByb3ZpZGVyVG9GYWN0b3J5IH0gZnJvbSAnLi4vZGkvdXRpbCc7XG5pbXBvcnQgeyBjb21waWxlTmdNb2R1bGUgYXMgcmVuZGVyM0NvbXBpbGVOZ01vZHVsZSB9IGZyb20gJy4uL3JlbmRlcjMvaml0L21vZHVsZSc7XG5pbXBvcnQgeyBtYWtlRGVjb3JhdG9yIH0gZnJvbSAnLi4vdXRpbC9kZWNvcmF0b3JzJztcbnZhciDJtTAgPSBmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIG5nTW9kdWxlOyB9LCDJtTEgPSBcbi8qKlxuICogRGVjb3JhdG9yIHRoYXQgbWFya3MgdGhlIGZvbGxvd2luZyBjbGFzcyBhcyBhbiBOZ01vZHVsZSwgYW5kIHN1cHBsaWVzXG4gKiBjb25maWd1cmF0aW9uIG1ldGFkYXRhIGZvciBpdC5cbiAqXG4gKiAqIFRoZSBgZGVjbGFyYXRpb25zYCBhbmQgYGVudHJ5Q29tcG9uZW50c2Agb3B0aW9ucyBjb25maWd1cmUgdGhlIGNvbXBpbGVyXG4gKiB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYmVsb25ncyB0byB0aGUgTmdNb2R1bGUuXG4gKiAqIFRoZSBgcHJvdmlkZXJzYCBvcHRpb25zIGNvbmZpZ3VyZXMgdGhlIE5nTW9kdWxlJ3MgaW5qZWN0b3IgdG8gcHJvdmlkZVxuICogZGVwZW5kZW5jaWVzIHRoZSBOZ01vZHVsZSBtZW1iZXJzLlxuICogKiBUaGUgYGltcG9ydHNgIGFuZCBgZXhwb3J0c2Agb3B0aW9ucyBicmluZyBpbiBtZW1iZXJzIGZyb20gb3RoZXIgbW9kdWxlcywgYW5kIG1ha2VcbiAqIHRoaXMgbW9kdWxlJ3MgbWVtYmVycyBhdmFpbGFibGUgdG8gb3RoZXJzLlxuICovXG5mdW5jdGlvbiAodHlwZSwgbWV0YSkgeyByZXR1cm4gU1dJVENIX0NPTVBJTEVfTkdNT0RVTEUodHlwZSwgbWV0YSk7IH07XG4vKipcbiAqIEBBbm5vdGF0aW9uXG4gKiBAcHVibGljQXBpXG4gKi9cbmV4cG9ydCB2YXIgTmdNb2R1bGUgPSBtYWtlRGVjb3JhdG9yKCdOZ01vZHVsZScsIMm1MCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIMm1MSk7XG5mdW5jdGlvbiBwcmVSM05nTW9kdWxlQ29tcGlsZShtb2R1bGVUeXBlLCBtZXRhZGF0YSkge1xuICAgIHZhciBpbXBvcnRzID0gKG1ldGFkYXRhICYmIG1ldGFkYXRhLmltcG9ydHMpIHx8IFtdO1xuICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5leHBvcnRzKSB7XG4gICAgICAgIGltcG9ydHMgPSBfX3NwcmVhZChpbXBvcnRzLCBbbWV0YWRhdGEuZXhwb3J0c10pO1xuICAgIH1cbiAgICBtb2R1bGVUeXBlLsm1aW5qID0gybXJtWRlZmluZUluamVjdG9yKHtcbiAgICAgICAgZmFjdG9yeTogY29udmVydEluamVjdGFibGVQcm92aWRlclRvRmFjdG9yeShtb2R1bGVUeXBlLCB7IHVzZUNsYXNzOiBtb2R1bGVUeXBlIH0pLFxuICAgICAgICBwcm92aWRlcnM6IG1ldGFkYXRhICYmIG1ldGFkYXRhLnByb3ZpZGVycyxcbiAgICAgICAgaW1wb3J0czogaW1wb3J0cyxcbiAgICB9KTtcbn1cbmV4cG9ydCB2YXIgU1dJVENIX0NPTVBJTEVfTkdNT0RVTEVfX1BPU1RfUjNfXyA9IHJlbmRlcjNDb21waWxlTmdNb2R1bGU7XG52YXIgU1dJVENIX0NPTVBJTEVfTkdNT0RVTEVfX1BSRV9SM19fID0gcHJlUjNOZ01vZHVsZUNvbXBpbGU7XG52YXIgU1dJVENIX0NPTVBJTEVfTkdNT0RVTEUgPSBTV0lUQ0hfQ09NUElMRV9OR01PRFVMRV9fUFJFX1IzX187XG5leHBvcnQgeyDJtTAsIMm1MSB9O1xuIl19